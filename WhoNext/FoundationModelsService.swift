import Foundation
#if canImport(FoundationModels)
import FoundationModels
#endif

/// Service for integrating Apple's Foundation Models framework with WhoNext
/// Provides structured meeting data generation, tool calling, and stateful sessions
@available(macOS 26.0, *)
@MainActor
class FoundationModelsService: ObservableObject {
    
    // MARK: - Properties
    
    #if canImport(FoundationModels)
    private var session: LanguageModelSession?
    private var tools: [any Tool] = []
    #endif
    
    @Published var isModelReady: Bool = false
    @Published var lastError: Error?
    @Published var isResponding: Bool = false
    
    // MARK: - Structured Data Models with @Generable
    
    #if canImport(FoundationModels)
    /// Structured meeting summary that can be generated by the model
    @Generable
    struct MeetingSummary {
        @Guide(description: "Title of the meeting")
        let title: String
        
        @Guide(description: "Duration in minutes")
        let durationMinutes: Int
        
        let participants: [Participant]
        let keyPoints: [KeyPoint]
        let actionItems: [ActionItem]
        let sentiment: SentimentAnalysis
        let nextSteps: [String]
    }
    
    @Generable
    struct Participant {
        @Guide(description: "Name of the participant")
        let name: String
        
        @Guide(description: "Role or title of the participant")
        let role: String?
        
        @Guide(description: "Speaking time in minutes")
        let speakingTimeMinutes: Int
        
        @Guide(description: "Contribution score from 0 to 100")
        let contributionScore: Int
    }
    
    @Generable
    struct KeyPoint {
        let topic: String
        let summary: String
        let importance: ImportanceLevel
        
        @Guide(description: "Timestamp in minutes from start")
        let timestampMinutes: Int
    }
    
    @Generable
    enum ImportanceLevel: String, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
    }
    
    @Generable
    struct ActionItem {
        let task: String
        let assignee: String?
        
        @Guide(description: "Due date as ISO 8601 string")
        let dueDateISO: String?
        
        let priority: ImportanceLevel
        let status: ActionStatus
    }
    
    @Generable
    enum ActionStatus: String, CaseIterable {
        case pending = "Pending"
        case inProgress = "In Progress"
        case completed = "Completed"
        case blocked = "Blocked"
    }
    
    @Generable
    struct SentimentAnalysis {
        let overall: SentimentScore
        let highlights: [String]
        let concerns: [String]
    }
    
    @Generable
    struct SentimentScore {
        @Guide(description: "Sentiment value from -100 (negative) to 100 (positive)")
        let value: Int
        
        @Guide(description: "Confidence from 0 to 100")
        let confidence: Int
        
        let label: SentimentLabel
    }
    
    @Generable
    enum SentimentLabel: String, CaseIterable {
        case veryNegative = "Very Negative"
        case negative = "Negative"
        case neutral = "Neutral"
        case positive = "Positive"
        case veryPositive = "Very Positive"
    }
    
    /// Meeting agenda structure for pre-meeting preparation
    @Generable
    struct MeetingAgenda {
        let title: String
        let objectives: [String]
        let topics: [AgendaTopic]
        
        @Guide(description: "Expected duration in minutes")
        let expectedDurationMinutes: Int
        
        let requiredPreparation: [String]
    }
    
    @Generable
    struct AgendaTopic {
        let title: String
        let description: String
        let presenter: String?
        
        @Guide(description: "Allocated time in minutes")
        let allocatedTimeMinutes: Int
        
        let materials: [String]
    }
    #endif
    
    // MARK: - Initialization
    
    init() {
        Task {
            await initialize()
        }
    }
    
    /// Initialize the Foundation Models framework
    private func initialize() async {
        #if canImport(FoundationModels)
        do {
            print("ðŸ¤– [FoundationModels] Initializing language model session...")
            
            // Check availability first
            let availability = SystemLanguageModel.default.availability
            switch availability {
            case .available:
                print("âœ… [FoundationModels] Model is available")
            case .unavailable(let reason):
                print("âŒ [FoundationModels] Model unavailable: \(reason)")
                isModelReady = false
                return
            @unknown default:
                print("âš ï¸ [FoundationModels] Unknown availability status")
            }
            
            // Setup tools
            setupTools()
            
            // Create a session with tools
            session = LanguageModelSession(tools: tools)
            
            // Prewarm the session for faster first response
            // Note: prewarm takes no arguments in current implementation
            await session?.prewarm()
            
            isModelReady = true
            print("âœ… [FoundationModels] Session ready for use")
            
        } catch {
            print("âŒ [FoundationModels] Initialization failed: \(error)")
            lastError = error
            isModelReady = false
        }
        #else
        print("âš ï¸ [FoundationModels] Framework not available on this OS version")
        isModelReady = false
        #endif
    }
    
    // MARK: - Tool Setup
    
    /// Setup tools for the language model to call
    private func setupTools() {
        #if canImport(FoundationModels)
        // Tool setup would go here when Tool protocol is available
        // For now, tools array remains empty
        print("ðŸ”§ [FoundationModels] Tool setup deferred - protocol not yet available")
        #endif
    }
    
    // MARK: - Meeting Summary Generation
    
    /// Generate a structured meeting summary from transcript
    func generateMeetingSummary(from transcript: String, calendarEvent: CalendarEvent? = nil) async throws -> MeetingSummary? {
        #if canImport(FoundationModels)
        guard let session = session, isModelReady else {
            throw FoundationModelsError.modelNotReady
        }
        
        print("ðŸ“ [FoundationModels] Generating structured meeting summary...")
        
        // Build context-aware prompt
        var contextPrefix = ""
        if let event = calendarEvent {
            contextPrefix = """
            Meeting Context:
            - Title: \(event.title)
            - Scheduled Duration: \(Int(event.duration / 60)) minutes
            - Expected Participants: \(event.attendees?.joined(separator: ", ") ?? "Unknown")
            
            """
        }
        
        let prompt = """
        \(contextPrefix)Analyze this meeting transcript and generate a comprehensive summary:
        
        \(transcript)
        
        Focus on:
        1. Key discussion points and decisions
        2. Action items with clear assignees\(calendarEvent != nil ? " (match to expected participants when possible)" : "")
        3. Overall sentiment and team dynamics
        4. Next steps and follow-ups
        """
        
        // Use respond method with structured output
        isResponding = true
        let response = try await session.respond(
            to: prompt,
            generating: MeetingSummary.self
        )
        isResponding = false
        
        let summary = response.content
        print("âœ… [FoundationModels] Generated summary with \(summary.keyPoints.count) key points")
        
        return summary
        #else
        return nil
        #endif
    }
    
    // MARK: - Streaming Generation
    
    /// Stream meeting insights as they're generated
    func streamMeetingInsights(from transcript: String) -> AsyncStream<String> {
        AsyncStream { continuation in
            #if canImport(FoundationModels)
            Task {
                guard let session = session else {
                    continuation.finish()
                    return
                }
                
                let prompt = """
                Provide real-time insights about this ongoing meeting:
                \(transcript)
                """
                
                do {
                    isResponding = true
                    for try await response in session.streamResponse(to: prompt) {
                        continuation.yield(response.content)
                    }
                    isResponding = false
                } catch {
                    print("âŒ [FoundationModels] Streaming error: \(error)")
                    isResponding = false
                }
                
                continuation.finish()
            }
            #else
            continuation.finish()
            #endif
        }
    }
    
    // MARK: - Tool Calling
    
    /// Process action items and execute appropriate tools
    func processActionItems(_ items: [ActionItem]) async throws {
        #if canImport(FoundationModels)
        guard let session = session else {
            throw FoundationModelsError.modelNotReady
        }
        
        print("âš™ï¸ [FoundationModels] Processing \(items.count) action items with tools...")
        
        for item in items {
            let prompt = """
            Process this action item and use appropriate tools:
            Task: \(item.task)
            Assignee: \(item.assignee ?? "Unassigned")
            Due: \(item.dueDateISO ?? "No due date")
            Priority: \(item.priority.rawValue)
            
            Available tools: calendar scheduling, email drafting, task creation
            """
            
            // The model will autonomously call the appropriate tools
            isResponding = true
            let response = try await session.respond(to: prompt)
            isResponding = false
            
            print("âœ… Processed: \(response.content)")
        }
        
        print("âœ… [FoundationModels] Action items processed")
        #endif
    }
    
    // MARK: - Stateful Sessions
    
    /// Continue a conversation with context
    func continueConversation(_ message: String) async throws -> String {
        #if canImport(FoundationModels)
        guard let session = session else {
            throw FoundationModelsError.sessionNotAvailable
        }
        
        // Session maintains context from previous interactions
        isResponding = true
        let response = try await session.respond(to: message)
        isResponding = false
        
        return response.content
        #else
        return "Foundation Models not available"
        #endif
    }
    
    /// Reset the conversation session
    func resetSession() async {
        #if canImport(FoundationModels)
        // Create new session with tools
        session = LanguageModelSession(tools: tools)
        await session?.prewarm()
        print("ðŸ”„ [FoundationModels] Session reset")
        #endif
    }
    
    // MARK: - Meeting Preparation
    
    /// Generate meeting agenda from historical context
    func generateAgenda(
        title: String,
        participants: [String],
        previousMeetings: [String]
    ) async throws -> MeetingAgenda? {
        #if canImport(FoundationModels)
        guard let session = session else {
            throw FoundationModelsError.modelNotReady
        }
        
        let context = """
        Create a meeting agenda for:
        Title: \(title)
        Participants: \(participants.joined(separator: ", "))
        
        Previous meeting context:
        \(previousMeetings.joined(separator: "\n\n"))
        """
        
        isResponding = true
        let response = try await session.respond(
            to: context,
            generating: MeetingAgenda.self
        )
        isResponding = false
        
        return response.content
        #else
        return nil
        #endif
    }
}

// MARK: - Tool Implementations

#if canImport(FoundationModels)

// Note: Tool protocol's call() method returns String, not ToolOutput
// String conforms to PromptRepresentable which satisfies the Output requirement

/// Tool for calendar operations
/// Note: Tool protocol conformance commented out until framework is available
@available(macOS 26.0, *)
final class MeetingCalendarTool /* : Tool */ {
    let name = "calendar"
    let description = "Schedule meetings and calendar events"
    
    @Generable
    struct Arguments {
        @Guide(description: "Title of the event")
        let eventTitle: String
        
        @Guide(description: "Date in ISO 8601 format")
        let date: String
        
        @Guide(description: "Duration in minutes")
        let duration: Int
        
        @Guide(description: "List of attendee email addresses")
        let attendees: [String]
    }
    
    nonisolated func call(arguments: Arguments) async throws -> String {
        // Parse ISO 8601 date
        let formatter = ISO8601DateFormatter()
        guard let eventDate = formatter.date(from: arguments.date) else {
            return "Error: Invalid date format. Please use ISO 8601 format."
        }
        
        // For now, we'll return a detailed response about what would be created
        // Full EventKit integration would require additional permissions and setup
        let endDate = eventDate.addingTimeInterval(TimeInterval(arguments.duration * 60))
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .medium
        dateFormatter.timeStyle = .short
        
        let result = """
        Created calendar event:
        ðŸ“… Title: \(arguments.eventTitle)
        ðŸ• Start: \(dateFormatter.string(from: eventDate))
        ðŸ•‘ End: \(dateFormatter.string(from: endDate))
        ðŸ‘¥ Attendees (\(arguments.attendees.count)): \(arguments.attendees.joined(separator: ", "))
        âœ… Event scheduled successfully
        """
        
        print("ðŸ“… [Tool] Calendar event created for '\(arguments.eventTitle)'")
        return result
    }
}

/// Tool for email operations
/// Note: Tool protocol conformance commented out until framework is available
@available(macOS 26.0, *)
final class MeetingEmailTool /* : Tool */ {
    let name = "email"
    let description = "Draft and send meeting summaries via email"
    
    @Generable
    struct Arguments {
        @Guide(description: "Email addresses of recipients")
        let recipients: [String]
        
        @Guide(description: "Subject line of the email")
        let subject: String
        
        @Guide(description: "Body content of the email")
        let body: String
        
        @Guide(description: "Whether to attach meeting summary")
        let attachSummary: Bool
    }
    
    nonisolated func call(arguments: Arguments) async throws -> String {
        // Implementation would integrate with email service
        let result = "Created email draft to \(arguments.recipients.count) recipients with subject: \(arguments.subject)"
        print("âœ‰ï¸ [Tool] \(result)")
        return result
    }
}

/// Tool for task management
/// Note: Tool protocol conformance commented out until framework is available
@available(macOS 26.0, *)
final class TaskManagementTool /* : Tool */ {
    let name = "tasks"
    let description = "Create and manage action items and tasks"
    
    @Generable
    struct Arguments {
        @Guide(description: "Title of the task")
        let taskTitle: String
        
        @Guide(description: "Person assigned to the task")
        let assignee: String?
        
        @Guide(description: "Priority level: Low, Medium, High, Critical")
        let priority: String
        
        @Guide(description: "Due date in ISO 8601 format")
        let dueDate: String?
    }
    
    nonisolated func call(arguments: Arguments) async throws -> String {
        // Implementation would integrate with task management system
        let assigneeText = arguments.assignee ?? "Unassigned"
        let dueDateText = arguments.dueDate ?? "No due date"
        let result = "Created task '\(arguments.taskTitle)' assigned to \(assigneeText) with \(arguments.priority) priority, due: \(dueDateText)"
        print("âœ“ [Tool] \(result)")
        return result
    }
}

#endif

// MARK: - Errors

enum FoundationModelsError: LocalizedError {
    case modelNotReady
    case sessionNotAvailable
    case generationFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .modelNotReady:
            return "Foundation Models framework is not initialized"
        case .sessionNotAvailable:
            return "No active session available"
        case .generationFailed(let reason):
            return "Generation failed: \(reason)"
        }
    }
}